define(["./Transforms-0503728c","./Matrix3-b2351961","./ComponentDatatype-ab629b88","./defaultValue-f6d5e6da","./GeometryAttribute-00041b84","./GeometryAttributes-1e4ddcd2","./IndexDatatype-a9b1bc18","./VertexFormat-fbdec922","./Math-355606c6","./Matrix2-7a8e9daf","./RuntimeError-9b4ce3fb","./combine-0c102d93","./WebGLConstants-7f557f93"],(function(e,t,a,r,n,o,i,s,u,m,p,c,y){"use strict";let l=new t.Cartesian3;function A(e){e=r.defaultValue(e,r.defaultValue.EMPTY_OBJECT),this._radius=e.radius,this._directions=e.directions,this._perDirectionRadius=e.perDirectionRadius,this._vertexFormat=r.defaultValue(e.vertexFormat,s.VertexFormat.DEFAULT),this._workerName="createFanGeometry"}return A.createGeometry=function(s){const u=s._vertexFormat,m=s._radius,p=r.defined(s._perDirectionRadius)&&s._perDirectionRadius,c=s._directions;let y,A;c[0].clock<c[1].clock&&c.reverse();let d,C,f,b,D,w=0;const x=new o.GeometryAttributes,h=[],F=[];let G=c.length;for(d=0;d<G;d++)b=t.Cartesian3.fromSpherical(c[d]),0===d?(h.push(b),F.push(t.Cartesian3.normalize(b,new t.Cartesian3))):t.Cartesian3.equals(h[d-1],b)||d===G-1&&t.Cartesian3.equals(h[0],b)||(h.push(b),F.push(t.Cartesian3.normalize(b,new t.Cartesian3)));if(G=h.length,u.position){D=2*(G+1)*3;const e=new Float64Array(D);for(C=0,d=0;d<G;d++){e[C++]=0,e[C++]=0,e[C++]=0,b=F[d];const a=p?t.Cartesian3.magnitude(h[d]):m;e[C++]=b.x*a,e[C++]=b.y*a,e[C++]=b.z*a,w=Math.max(w,a)}e[C++]=e[0],e[C++]=e[1],e[C++]=e[2],e[C++]=e[3],e[C++]=e[4],e[C++]=e[5],x.position=new n.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e})}if(u.normal){let e;for(D=2*(G+1)*3,y=new Float32Array(D),C=0,d=0;d<G;d++)b=h[d],e=d+1===G?h[0]:h[d+1],l=t.Cartesian3.normalize(t.Cartesian3.cross(b,e,l),l),y[C++]=l.x,y[C++]=l.y,y[C++]=l.z,y[C++]=l.x,y[C++]=l.y,y[C++]=l.z;y[C++]=y[0],y[C++]=y[1],y[C++]=y[2],y[C++]=y[3],y[C++]=y[4],y[C++]=y[5],x.normal=new n.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:y})}if(u.bitangent){for(D=2*(G+1)*3,A=new Float32Array(D),C=0,d=0;d<G;d++)b=F[d],A[C++]=b.x,A[C++]=b.y,A[C++]=b.z,A[C++]=b.x,A[C++]=b.y,A[C++]=b.z;A[C++]=A[0],A[C++]=A[1],A[C++]=A[2],A[C++]=A[3],A[C++]=A[4],A[C++]=A[5],x.bitangent=new n.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:A})}if(u.tangent){D=2*(G+1)*3;const e=new Float32Array(D);for(C=0,d=0;d<D;d+=6){const a=t.Cartesian3.unpack(y,d),r=t.Cartesian3.unpack(A,d),n=t.Cartesian3.normalize(t.Cartesian3.cross(r,a,l),l);e[C++]=n.x,e[C++]=n.y,e[C++]=n.z,e[C++]=n.x,e[C++]=n.y,e[C++]=n.z}x.tangent=new n.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e})}if(u.st){D=2*(G+1)*2;const e=new Float32Array(D);for(C=0,d=0;d<G;d++)f=1-d/(G+1),e[C++]=f,e[C++]=0,e[C++]=f,e[C++]=1;f=1-d/(G+1),e[C++]=f,e[C++]=0,e[C++]=f,e[C++]=1,x.st=new n.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:e})}C=0,d=0,D=2*(G+1)*3;const T=i.IndexDatatype.createTypedArray(D/3,D);for(;C<D-6;)T[C++]=d,T[C++]=d+3,T[C++]=d+1,T[C++]=d,T[C++]=d+2,T[C++]=d+3,d+=2;return T[C++]=d,T[C++]=1,T[C++]=d+1,T[C++]=d,T[C++]=0,T[C++]=1,new n.Geometry({attributes:x,indices:T,primitiveType:n.PrimitiveType.TRIANGLES,boundingSphere:new e.BoundingSphere(t.Cartesian3.ZERO,w)})},A.createGeometry}));
